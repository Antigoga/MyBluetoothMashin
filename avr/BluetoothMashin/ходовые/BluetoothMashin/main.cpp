/****************************************************************************
ПРОГРАММА ДЛЯ МАШИНЫ, НА BLUETOOTH УПРАВЛЕНИИ
*****************************************************************************/
//ЧАСТОТА МК
#define F_CPU 8000000UL//частота atmega8
#define BAUD 9600 //БЛЮТУЗ скорость в бодах
#define BAUD_PRESCALE ((F_CPU)/(16UL*BAUD)-1) //Предделитель частоты 


//ПОДЕЛЮЧЕНИЕ НЕОБХОДИМЫХ БИБЛИОТЕК
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

//ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ, ХРАНЯЩИЕ ПРЕЛЫДУЩЕЕ ЗНАЧЕНИЕ UDR И СЛЕДУЮЩЕЕ
//ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ, ХРАНЯЩИЕ ПРЕЛЫДУЩЕЕ ЗНАЧЕНИЕ UDR И СЛЕДУЮЩЕЕ
volatile unsigned char temp1 = 99;//Вот пришло по UART значение , мы его сюда записали, а на 2 шаге
volatile unsigned char temp2 = 99;//а на 2 шаге вот сюда записали, а на 3 шаге 1 значение удаляем, а 3 значение
volatile unsigned char braker = '1';//переменная ручника

//НАЧАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ ПОРТОВ УПРАВЛЕНИЯ МОТОРАМИ И СЕРВОПРИВОДОМ
void port_init()
{
	//инициализация портов управления двигателями
	DDRC |=(1<<0);// правый вперёд
	DDRC |=(1<<1);// правый назад
	DDRC |=(1<<2);//левый вперёд
	DDRC |=(1<<3);// левый назад
	
	//установка начальных значений - все двигатели стоят
	PORTC |=(0<<0);
	PORTC |=(0<<1);
	PORTC |=(0<<2);
	PORTC |=(0<<3);
	
	//инициализация ходовых задних огней
	DDRC |= (1<<4);
	DDRC |= (1<<5);
	PORTC &=(0<<4);
	PORTC &=(0<<5);
}

//ОБРАБОТЧИК ПРЕРЫВАНИЯ
ISR(USART_RXC_vect)
{	
	temp2 = UDR;	
}

//ИНИЦИАЛИЗАЦИЯ UART
void InitUART(void)
{
	UCSRB = 0b00011000;
	UCSRB |=(1<<RXCIE);
	UCSRC = 0b10000011;
	UBRRH=(BAUD_PRESCALE>>8);
	UBRRL=BAUD_PRESCALE;
}

//------------------------------------------------------------------------------
// Главная программа
//------------------------------------------------------------------------------
int main(void)
{
	//Функции начальной инициализации
	port_init();
	InitUART();
			
	sei();// разршаем прерывания
	
	// бесконечный цикл
	while(1) 
	{
				
		if(temp1 != temp2)//выполн¤ем действие только в том случае, если текущая команда другая
		{
			
			switch(braker)
			{
			
			//нет ручника
			case '0':	
			switch(temp2)
			{
				case '8'://движение вперёд
				PORTC &=(0<<0);//выключаем задний ход
				PORTC &=(0<<2);
				_delay_ms(25);// выжидаем скачок
				PORTC |=(1<<1);//включаем передний ход
				PORTC |=(1<<3);
				_delay_ms(25);//выжидаем скачок
				break;
				
			    case '5':	//стоп
				PORTC &=(0<<0);//выключаем все двигатели
				PORTC &=(0<<2);
				PORTC &=(0<<1);
				PORTC &=(0<<3);
				PORTC &=(0<<4);
				PORTC &=(0<<5);
				_delay_ms(50);// выжидаем скачок
				break;
				
				case '2': //движение назад
				PORTC &=(0<<1);//выключаем передний ход
				PORTC |=(1<<4);
				PORTC |=(1<<5);
				PORTC &=(0<<3);
				_delay_ms(25);// выжидаем скачок
				PORTC |=(1<<0);//включаем задний ход
				PORTC |=(1<<2);
				PORTC |=(1<<4);
				PORTC |=(1<<5);
				_delay_ms(25);// выжидаем скачок
				break;
				
				case '3':
				braker =char(int(!(bool(char(braker)-48)))+48);
				break;
		
			}
			temp1=temp2;//сохраняем текущее значение для сравнения
			break;
			
			//есть ручник
			case '1':
			switch(temp2)
			{
				case '5':	//стоп
				PORTC &=(0<<0);//выключаем все двигатели
				PORTC &=(0<<2);
				PORTC &=(0<<1);
				PORTC &=(0<<3);
				PORTC &=(0<<4);
				PORTC &=(0<<5);
				_delay_ms(50);// выжидаем скачок
				break;
				
				case '3':
				braker =char(int(!(bool(char(braker)-48)))+48);
				break;
			}
			temp1=temp2;//сохраняем текущее значение для сравнения
			break;
			
		}
				
	} // закрывающая скобка бесконечного цикла
		}
return 0;
 // закрывающая скобка основной программы
}
